# Sprint 2.2: 코드 생성 시스템 - 상세 구현 가이드

## 🎯 Sprint 목표
건물 타입별 코드 자동 생성 시스템을 구현하고, 생성된 코드의 품질을 보장하는 후처리 시스템을 구축합니다.

## 🛠️ 핵심 구현 사항
- 건물별 코드 생성기 (API, Database, Frontend)
- 컨텍스트 기반 코드 생성
- 코드 검증 및 포맷팅
- 의존성 추출 시스템
- 파일 구조 생성

## 📋 Task 1: 건물별 코드 생성기

### 1.1 코드 생성기 베이스 클래스 (src/services/ai/generators/base.ts)
```typescript
// irke://stack/ai/generator/base
import { Building } from '@/types'
import { AIContext, GeneratedCode, CodeFile } from '../types'
import { QwenClient } from '../client'
import { PromptTemplateManager } from '../prompts/manager'
import { ContextBuilder } from '../context/builder'

export abstract class BaseCodeGenerator {
  protected client: QwenClient
  protected templateManager: PromptTemplateManager
  protected contextBuilder: ContextBuilder

  constructor() {
    this.client = new QwenClient()
    this.templateManager = new PromptTemplateManager()
    this.contextBuilder = new ContextBuilder()
  }

  abstract generateCode(building: Building, context: AIContext): Promise<GeneratedCode>
  abstract getDefaultFiles(building: Building): CodeFile[]
  abstract extractDependencies(code: string): string[]

  protected async callAI(systemPrompt: string, userPrompt: string): Promise<string> {
    const response = await this.client.chat([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ])

    return response.choices[0].message.content
  }

  protected parseCodeBlocks(response: string): CodeFile[] {
    const files: CodeFile[] = []
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g
    const filePathRegex = /\/\/\s*(?:File:|Path:)\s*(.+)/i

    let match
    while ((match = codeBlockRegex.exec(response)) !== null) {
      const language = match[1] || 'plaintext'
      const content = match[2].trim()

      // 파일 경로 추출
      const pathMatch = content.match(filePathRegex)
      const path = pathMatch ? pathMatch[1].trim() : this.generateFilePath(language)

      // 파일 경로 주석 제거
      const cleanContent = content.replace(filePathRegex, '').trim()

      files.push({
        path,
        content: cleanContent,
        language,
      })
    }

    return files
  }

  protected generateFilePath(language: string): string {
    const timestamp = Date.now()
    const extensions: Record<string, string> = {
      typescript: 'ts',
      javascript: 'js',
      tsx: 'tsx',
      jsx: 'jsx',
      sql: 'sql',
      json: 'json',
      yaml: 'yaml',
      css: 'css',
    }

    const ext = extensions[language] || 'txt'
    return `generated_${timestamp}.${ext}`
  }

  protected validateGeneratedCode(code: GeneratedCode): GeneratedCode {
    // 기본 검증
    if (!code.files || code.files.length === 0) {
      throw new Error('No files generated')
    }

    // 각 파일 검증
    code.files.forEach(file => {
      if (!file.path || !file.content) {
        throw new Error('Invalid file structure')
      }
    })

    return code
  }

  protected addBoilerplate(files: CodeFile[], building: Building): CodeFile[] {
    return files.map(file => ({
      ...file,
      content: this.addFileHeader(file.content, building),
    }))
  }

  private addFileHeader(content: string, building: Building): string {
    const header = `/**
 * Generated by IRKE TOWN AI
 * Building: ${building.name} (${building.type})
 * Date: ${new Date().toISOString()}
 */

`
    return header + content
  }
}
```

### 1.2 API Gateway 코드 생성기 (src/services/ai/generators/api.ts)
```typescript
// irke://component/building/api/generator
import { Building } from '@/types'
import { AIContext, GeneratedCode, CodeFile } from '../types'
import { BaseCodeGenerator } from './base'

export class ApiCodeGenerator extends BaseCodeGenerator {
  async generateCode(building: Building, context: AIContext): Promise<GeneratedCode> {
    // 1. 연결된 데이터베이스 찾기
    const connectedDb = context.connectedBuildings.find(b => b.type === 'database')
    
    // 2. 프롬프트 준비
    const templateId = 'generate-api-endpoint'
    const variables = {
      buildingType: 'API Gateway',
      buildingName: building.name,
      connectedBuildings: context.connectedBuildings.map(b => `${b.name} (${b.type})`).join(', '),
      techStack: context.techStack.join(', '),
      projectType: context.projectType,
      requirements: this.generateRequirements(building, context),
    }

    const userPrompt = this.templateManager.fillTemplate(templateId, variables)
    
    // 3. AI 호출
    const systemPrompt = `You are an expert backend developer specializing in REST API development with ${context.techStack.join(', ')}. 
Generate production-ready, secure, and well-documented API code.`

    const response = await this.callAI(systemPrompt, userPrompt)
    
    // 4. 코드 파싱
    let files = this.parseCodeBlocks(response)
    
    // 5. 기본 파일 추가 (생성되지 않은 경우)
    if (files.length === 0) {
      files = this.getDefaultFiles(building)
    }
    
    // 6. 보일러플레이트 추가
    files = this.addBoilerplate(files, building)
    
    // 7. 의존성 추출
    const dependencies = this.extractDependencies(files.map(f => f.content).join('\n'))
    
    const generatedCode: GeneratedCode = {
      buildingId: building.id,
      files,
      dependencies,
      instructions: `
API Gateway "${building.name}" has been generated with the following endpoints:
- GET /api/${building.name.toLowerCase()}
- POST /api/${building.name.toLowerCase()}
- PUT /api/${building.name.toLowerCase()}/:id
- DELETE /api/${building.name.toLowerCase()}/:id

To use this API:
1. Install dependencies: npm install ${dependencies.join(' ')}
2. Set up your database connection
3. Run the server
      `.trim(),
    }

    return this.validateGeneratedCode(generatedCode)
  }

  getDefaultFiles(building: Building): CodeFile[] {
    const name = building.name.toLowerCase().replace(/\s+/g, '-')
    
    return [
      {
        path: `src/app/api/${name}/route.ts`,
        content: `import { NextRequest, NextResponse } from 'next/server'

// GET: 목록 조회
export async function GET(request: NextRequest) {
  try {
    // TODO: 데이터베이스에서 데이터 조회
    const data = []
    
    return NextResponse.json({
      success: true,
      data,
      metadata: {
        total: data.length,
      },
    })
  } catch (error) {
    console.error('GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

// POST: 새 항목 생성
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // TODO: 입력 검증
    if (!body.name) {
      return NextResponse.json(
        { success: false, error: 'Name is required' },
        { status: 400 }
      )
    }
    
    // TODO: 데이터베이스에 저장
    const newItem = {
      id: Date.now().toString(),
      ...body,
      createdAt: new Date().toISOString(),
    }
    
    return NextResponse.json(
      { success: true, data: newItem },
      { status: 201 }
    )
  } catch (error) {
    console.error('POST error:', error)
    return NextResponse.json(
      { success: false, error: 'Bad Request' },
      { status: 400 }
    )
  }
}`,
        language: 'typescript',
      },
      {
        path: `src/app/api/${name}/[id]/route.ts`,
        content: `import { NextRequest, NextResponse } from 'next/server'

// GET: 단일 항목 조회
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params
    
    // TODO: 데이터베이스에서 조회
    const item = null // 임시
    
    if (!item) {
      return NextResponse.json(
        { success: false, error: 'Not Found' },
        { status: 404 }
      )
    }
    
    return NextResponse.json({ success: true, data: item })
  } catch (error) {
    console.error('GET error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

// PUT: 항목 수정
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params
    const body = await request.json()
    
    // TODO: 데이터베이스에서 업데이트
    const updatedItem = {
      id,
      ...body,
      updatedAt: new Date().toISOString(),
    }
    
    return NextResponse.json({ success: true, data: updatedItem })
  } catch (error) {
    console.error('PUT error:', error)
    return NextResponse.json(
      { success: false, error: 'Bad Request' },
      { status: 400 }
    )
  }
}

// DELETE: 항목 삭제
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params
    
    // TODO: 데이터베이스에서 삭제
    
    return NextResponse.json({ success: true, message: 'Deleted successfully' })
  } catch (error) {
    console.error('DELETE error:', error)
    return NextResponse.json(
      { success: false, error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}`,
        language: 'typescript',
      },
    ]
  }

  extractDependencies(code: string): string[] {
    const dependencies: Set<string> = new Set()
    
    // import 문에서 패키지 추출
    const importRegex = /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g
    let match
    
    while ((match = importRegex.exec(code)) !== null) {
      const pkg = match[1]
      // 내장 모듈이나 상대 경로가 아닌 경우만
      if (!pkg.startsWith('.') && !pkg.startsWith('@/') && !pkg.includes('next')) {
        dependencies.add(pkg)
      }
    }
    
    // 특정 코드 패턴에서 필요한 패키지 추론
    if (code.includes('prisma')) {
      dependencies.add('@prisma/client')
      dependencies.add('prisma')
    }
    
    if (code.includes('zod')) {
      dependencies.add('zod')
    }
    
    if (code.includes('bcrypt')) {
      dependencies.add('bcryptjs')
      dependencies.add('@types/bcryptjs')
    }
    
    return Array.from(dependencies)
  }

  private generateRequirements(building: Building, context: AIContext): string {
    const requirements: string[] = []
    
    // 기본 CRUD 요구사항
    requirements.push('- Implement full CRUD operations (Create, Read, Update, Delete)')
    requirements.push('- Use RESTful conventions')
    requirements.push('- Include proper error handling and status codes')
    
    // 연결된 데이터베이스가 있는 경우
    const hasDb = context.connectedBuildings.some(b => b.type === 'database')
    if (hasDb) {
      requirements.push('- Include database integration code (using Prisma or native driver)')
      requirements.push('- Add data validation before database operations')
    }
    
    // 인증이 필요한 경우
    const hasAuth = context.townState.buildings.some(b => 
      b.name.toLowerCase().includes('auth') || 
      b.name.toLowerCase().includes('인증')
    )
    if (hasAuth) {
      requirements.push('- Add authentication middleware')
      requirements.push('- Validate JWT tokens for protected routes')
    }
    
    return requirements.join('\n')
  }
}
```

### 1.3 Database 코드 생성기 (src/services/ai/generators/database.ts)
```typescript
// irke://component/building/database/generator
import { Building } from '@/types'
import { AIContext, GeneratedCode, CodeFile } from '../types'
import { BaseCodeGenerator } from './base'

export class DatabaseCodeGenerator extends BaseCodeGenerator {
  async generateCode(building: Building, context: AIContext): Promise<GeneratedCode> {
    // 1. 연결된 API들 분석
    const connectedApis = context.connectedBuildings.filter(b => b.type === 'api')
    
    // 2. 데이터베이스 타입 결정 (기본: PostgreSQL)
    const dbType = this.detectDatabaseType(context)
    
    // 3. 프롬프트 준비
    const templateId = 'generate-db-schema'
    const variables = {
      databaseType: dbType,
      buildingName: building.name,
      connectedAPIs: connectedApis.map(api => api.name).join(', '),
      dataRequirements: this.analyzeDataRequirements(building, context),
    }

    const userPrompt = this.templateManager.fillTemplate(templateId, variables)
    
    // 4. AI 호출
    const systemPrompt = `You are a database architect expert in ${dbType}. 
Design efficient, normalized database schemas with proper indexes and constraints.
Include relationships, data types, and sample data.`

    const response = await this.callAI(systemPrompt, userPrompt)
    
    // 5. 코드 파싱
    let files = this.parseCodeBlocks(response)
    
    // 6. 기본 파일 생성
    if (files.length === 0) {
      files = this.getDefaultFiles(building)
    }
    
    // 7. Prisma 스키마 추가 (Next.js 프로젝트인 경우)
    if (context.techStack.includes('Next.js')) {
      files.push(this.generatePrismaSchema(building, files))
    }
    
    // 8. 마이그레이션 파일 추가
    files.push(this.generateMigrationFile(building, files))
    
    const dependencies = this.extractDependencies(files.map(f => f.content).join('\n'))
    
    const generatedCode: GeneratedCode = {
      buildingId: building.id,
      files,
      dependencies,
      instructions: `
Database "${building.name}" schema has been generated.

To set up the database:
1. Create a ${dbType} database
2. Update your .env file with the database connection string
3. Run migrations: ${dbType === 'PostgreSQL' ? 'npx prisma migrate dev' : 'Run the SQL script'}
4. (Optional) Seed the database with sample data

Connection string format:
${this.getConnectionStringExample(dbType)}
      `.trim(),
    }

    return this.validateGeneratedCode(generatedCode)
  }

  getDefaultFiles(building: Building): CodeFile[] {
    return [
      {
        path: 'database/schema.sql',
        content: `-- Database schema for ${building.name}

-- Users table
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  full_name VARCHAR(255),
  avatar_url VARCHAR(500),
  is_active BOOLEAN DEFAULT true,
  role VARCHAR(50) DEFAULT 'user',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Products table (example)
CREATE TABLE IF NOT EXISTS products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  slug VARCHAR(255) UNIQUE NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'USD',
  stock_quantity INTEGER DEFAULT 0,
  category_id INTEGER,
  is_active BOOLEAN DEFAULT true,
  created_by INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Categories table
CREATE TABLE IF NOT EXISTS categories (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  slug VARCHAR(100) UNIQUE NOT NULL,
  description TEXT,
  parent_id INTEGER REFERENCES categories(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add foreign key for products
ALTER TABLE products 
ADD CONSTRAINT fk_products_category 
FOREIGN KEY (category_id) REFERENCES categories(id);

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_products_slug ON products(slug);
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_categories_parent ON categories(parent_id);

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER users_updated_at BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER products_updated_at BEFORE UPDATE ON products
FOR EACH ROW EXECUTE FUNCTION update_updated_at();`,
        language: 'sql',
      },
      {
        path: 'database/seed.sql',
        content: `-- Seed data for ${building.name}

-- Insert sample users
INSERT INTO users (email, username, password_hash, full_name, role) VALUES
('admin@example.com', 'admin', '$2b$10$YourHashHere', 'Admin User', 'admin'),
('user1@example.com', 'user1', '$2b$10$YourHashHere', 'Test User 1', 'user'),
('user2@example.com', 'user2', '$2b$10$YourHashHere', 'Test User 2', 'user');

-- Insert sample categories
INSERT INTO categories (name, slug, description) VALUES
('Electronics', 'electronics', 'Electronic devices and accessories'),
('Books', 'books', 'Physical and digital books'),
('Clothing', 'clothing', 'Fashion and apparel');

-- Insert sample products
INSERT INTO products (name, slug, description, price, stock_quantity, category_id, created_by) VALUES
('Laptop Pro 15"', 'laptop-pro-15', 'High-performance laptop for professionals', 1299.99, 50, 1, 1),
('JavaScript: The Good Parts', 'javascript-good-parts', 'Classic JavaScript programming book', 29.99, 100, 2, 1),
('Developer T-Shirt', 'developer-tshirt', 'Comfortable cotton t-shirt with code jokes', 19.99, 200, 3, 1);`,
        language: 'sql',
      },
    ]
  }

  extractDependencies(code: string): string[] {
    const dependencies: Set<string> = new Set()
    
    // Prisma 감지
    if (code.includes('prisma') || code.includes('@prisma')) {
      dependencies.add('@prisma/client')
      dependencies.add('prisma')
    }
    
    // 다른 ORM 감지
    if (code.includes('typeorm')) {
      dependencies.add('typeorm')
      dependencies.add('reflect-metadata')
    }
    
    if (code.includes('sequelize')) {
      dependencies.add('sequelize')
    }
    
    // 데이터베이스 드라이버
    if (code.toLowerCase().includes('postgresql') || code.toLowerCase().includes('postgres')) {
      dependencies.add('pg')
      dependencies.add('@types/pg')
    }
    
    if (code.toLowerCase().includes('mysql')) {
      dependencies.add('mysql2')
    }
    
    if (code.toLowerCase().includes('mongodb')) {
      dependencies.add('mongodb')
    }
    
    return Array.from(dependencies)
  }

  private detectDatabaseType(context: AIContext): string {
    // 기술 스택에서 데이터베이스 타입 감지
    const techStack = context.techStack.join(' ').toLowerCase()
    
    if (techStack.includes('postgresql') || techStack.includes('postgres')) {
      return 'PostgreSQL'
    }
    if (techStack.includes('mysql')) {
      return 'MySQL'
    }
    if (techStack.includes('mongodb')) {
      return 'MongoDB'
    }
    
    // 기본값
    return 'PostgreSQL'
  }

  private analyzeDataRequirements(building: Building, context: AIContext): string {
    const requirements: string[] = []
    
    // 프로젝트 타입별 요구사항
    switch (context.projectType) {
      case 'webapp':
        requirements.push('- User authentication and profile management')
        requirements.push('- Session or token storage')
        requirements.push('- Content management tables')
        break
      case 'fullstack':
        requirements.push('- Complete user management system')
        requirements.push('- Business logic entities')
        requirements.push('- Audit trails and logging')
        break
      case 'api':
        requirements.push('- API key management')
        requirements.push('- Rate limiting data')
        requirements.push('- Request/response logging')
        break
    }
    
    // 연결된 건물 분석
    const hasAuth = context.townState.buildings.some(b => 
      b.name.toLowerCase().includes('auth')
    )
    if (hasAuth) {
      requirements.push('- User roles and permissions')
      requirements.push('- OAuth provider data')
    }
    
    const hasEcommerce = context.townState.buildings.some(b => 
      b.name.toLowerCase().includes('shop') || 
      b.name.toLowerCase().includes('product')
    )
    if (hasEcommerce) {
      requirements.push('- Product catalog with categories')
      requirements.push('- Shopping cart and orders')
      requirements.push('- Payment transaction records')
    }
    
    return requirements.join('\n')
  }

  private generatePrismaSchema(building: Building, sqlFiles: CodeFile[]): CodeFile {
    // SQL 파일에서 Prisma 스키마 생성
    const sqlContent = sqlFiles.find(f => f.path.includes('schema.sql'))?.content || ''
    
    return {
      path: 'prisma/schema.prisma',
      content: `// Prisma schema for ${building.name}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  username     String   @unique
  passwordHash String   @map("password_hash")
  fullName     String?  @map("full_name")
  avatarUrl    String?  @map("avatar_url")
  isActive     Boolean  @default(true) @map("is_active")
  role         String   @default("user")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  products     Product[] @relation("CreatedProducts")
  
  @@map("users")
}

model Category {
  id          Int       @id @default(autoincrement())
  name        String
  slug        String    @unique
  description String?
  parentId    Int?      @map("parent_id")
  parent      Category? @relation("CategoryTree", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryTree")
  products    Product[]
  createdAt   DateTime  @default(now()) @map("created_at")
  
  @@map("categories")
}

model Product {
  id             Int      @id @default(autoincrement())
  name           String
  slug           String   @unique
  description    String?
  price          Decimal  @db.Decimal(10, 2)
  currency       String   @default("USD")
  stockQuantity  Int      @default(0) @map("stock_quantity")
  categoryId     Int?     @map("category_id")
  category       Category? @relation(fields: [categoryId], references: [id])
  isActive       Boolean  @default(true) @map("is_active")
  createdById    Int      @map("created_by")
  createdBy      User     @relation("CreatedProducts", fields: [createdById], references: [id])
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")
  
  @@index([slug])
  @@index([categoryId])
  @@map("products")
}`,
      language: 'prisma',
    }
  }

  private generateMigrationFile(building: Building, files: CodeFile[]): CodeFile {
    const timestamp = new Date().toISOString().replace(/[:\-T.]/g, '').slice(0, 14)
    
    return {
      path: `database/migrations/${timestamp}_initial_schema.sql`,
      content: `-- Migration: Initial schema for ${building.name}
-- Created: ${new Date().toISOString()}

BEGIN;

${files.find(f => f.path.includes('schema.sql'))?.content || '-- No schema found'}

COMMIT;`,
      language: 'sql',
    }
  }

  private getConnectionStringExample(dbType: string): string {
    switch (dbType) {
      case 'PostgreSQL':
        return 'DATABASE_URL="postgresql://user:password@localhost:5432/dbname?schema=public"'
      case 'MySQL':
        return 'DATABASE_URL="mysql://user:password@localhost:3306/dbname"'
      case 'MongoDB':
        return 'DATABASE_URL="mongodb://user:password@localhost:27017/dbname"'
      default:
        return 'DATABASE_URL="your-database-connection-string"'
    }
  }
}
```

### 1.4 Frontend 코드 생성기 (src/services/ai/generators/frontend.ts)
```typescript
// irke://component/building/frontend/generator
import { Building } from '@/types'
import { AIContext, GeneratedCode, CodeFile } from '../types'
import { BaseCodeGenerator } from './base'

export class FrontendCodeGenerator extends BaseCodeGenerator {
  async generateCode(building: Building, context: AIContext): Promise<GeneratedCode> {
    // 1. 연결된 API 분석
    const connectedApis = context.connectedBuildings.filter(b => b.type === 'api')
    
    // 2. UI 프레임워크 확인
    const uiFramework = this.detectUIFramework(context)
    const stateManagement = this.detectStateManagement(context)
    
    // 3. 컴포넌트 타입 결정
    const componentType = this.determineComponentType(building, context)
    
    // 4. 프롬프트 준비
    const templateId = 'generate-frontend-component'
    const variables = {
      componentPurpose: this.getComponentPurpose(building, componentType),
      connectedAPIs: connectedApis.map(api => api.name).join(', '),
      uiFramework,
      stateManagement,
      requirements: this.generateUIRequirements(building, context, componentType),
    }

    const userPrompt = this.templateManager.fillTemplate(templateId, variables)
    
    // 5. AI 호출
    const systemPrompt = `You are a senior frontend developer expert in ${uiFramework} and ${stateManagement}. 
Create modern, accessible, and responsive React components with TypeScript.
Use Tailwind CSS for styling and follow best practices for performance and UX.`

    const response = await this.callAI(systemPrompt, userPrompt)
    
    // 6. 코드 파싱
    let files = this.parseCodeBlocks(response)
    
    // 7. 기본 파일 생성
    if (files.length === 0) {
      files = this.getDefaultFiles(building)
    }
    
    // 8. 추가 파일 생성
    // 타입 정의 파일
    files.push(this.generateTypeDefinitions(building, connectedApis))
    
    // API 훅 파일 (연결된 API가 있는 경우)
    if (connectedApis.length > 0) {
      files.push(this.generateApiHooks(building, connectedApis))
    }
    
    // 스타일 파일 (필요한 경우)
    if (componentType === 'dashboard' || componentType === 'form') {
      files.push(this.generateStyles(building))
    }
    
    const dependencies = this.extractDependencies(files.map(f => f.content).join('\n'))
    
    const generatedCode: GeneratedCode = {
      buildingId: building.id,
      files,
      dependencies,
      instructions: `
Frontend component "${building.name}" has been generated.

Component features:
- Type: ${componentType}
- Framework: ${uiFramework}
- State Management: ${stateManagement}
- Connected APIs: ${connectedApis.length > 0 ? connectedApis.map(a => a.name).join(', ') : 'None'}

To use this component:
1. Install dependencies: npm install ${dependencies.join(' ')}
2. Import and use in your application
3. Configure API endpoints if needed
4. Customize styles and behavior as needed

Example usage:
\`\`\`tsx
import { ${this.getComponentName(building)} } from '@/components/${this.getComponentPath(building)}'

function App() {
  return <${this.getComponentName(building)} />
}
\`\`\`
      `.trim(),
      warnings: this.generateWarnings(context),
    }

    return this.validateGeneratedCode(generatedCode)
  }

  getDefaultFiles(building: Building): CodeFile[] {
    const componentName = this.getComponentName(building)
    const path = this.getComponentPath(building)
    
    return [
      {
        path: `src/components/${path}/index.tsx`,
        content: `'use client'

import { useState, useEffect } from 'react'
import { ${componentName}Props, ${componentName}State } from './types'

export function ${componentName}({ className = '' }: ${componentName}Props) {
  const [state, setState] = useState<${componentName}State>({
    isLoading: false,
    error: null,
    data: null,
  })

  useEffect(() => {
    // Component initialization
    console.log('${componentName} mounted')
  }, [])

  return (
    <div className={\`\${className} p-6 bg-white rounded-lg shadow-sm\`}>
      <h2 className="text-2xl font-bold mb-4">${building.name}</h2>
      
      {state.isLoading && (
        <div className="flex items-center justify-center py-12">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      )}
      
      {state.error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          Error: {state.error}
        </div>
      )}
      
      {!state.isLoading && !state.error && (
        <div className="space-y-4">
          <p className="text-gray-600">
            This is the ${building.name} component. Customize it based on your needs.
          </p>
          
          {/* Add your component content here */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <div className="p-4 border rounded">
              <h3 className="font-semibold">Feature 1</h3>
              <p className="text-sm text-gray-500">Description</p>
            </div>
            <div className="p-4 border rounded">
              <h3 className="font-semibold">Feature 2</h3>
              <p className="text-sm text-gray-500">Description</p>
            </div>
            <div className="p-4 border rounded">
              <h3 className="font-semibold">Feature 3</h3>
              <p className="text-sm text-gray-500">Description</p>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default ${componentName}`,
        language: 'tsx',
      },
    ]
  }

  extractDependencies(code: string): string[] {
    const dependencies: Set<string> = new Set()
    
    // React hooks
    if (code.includes('useSWR')) {
      dependencies.add('swr')
    }
    
    if (code.includes('useQuery') || code.includes('useMutation')) {
      dependencies.add('@tanstack/react-query')
    }
    
    if (code.includes('useForm')) {
      dependencies.add('react-hook-form')
    }
    
    // UI 라이브러리
    if (code.includes('lucide-react')) {
      dependencies.add('lucide-react')
    }
    
    if (code.includes('@headlessui')) {
      dependencies.add('@headlessui/react')
    }
    
    if (code.includes('react-hot-toast')) {
      dependencies.add('react-hot-toast')
    }
    
    // 차트 라이브러리
    if (code.includes('recharts')) {
      dependencies.add('recharts')
    }
    
    // 유틸리티
    if (code.includes('clsx')) {
      dependencies.add('clsx')
    }
    
    if (code.includes('date-fns')) {
      dependencies.add('date-fns')
    }
    
    return Array.from(dependencies)
  }

  private detectUIFramework(context: AIContext): string {
    const techStack = context.techStack.join(' ').toLowerCase()
    
    if (techStack.includes('next')) {
      return 'Next.js with React'
    }
    if (techStack.includes('react')) {
      return 'React'
    }
    
    return 'React' // 기본값
  }

  private detectStateManagement(context: AIContext): string {
    const techStack = context.techStack.join(' ').toLowerCase()
    
    if (techStack.includes('zustand')) {
      return 'Zustand'
    }
    if (techStack.includes('redux')) {
      return 'Redux Toolkit'
    }
    if (techStack.includes('mobx')) {
      return 'MobX'
    }
    
    return 'React Hooks (useState, useContext)'
  }

  private determineComponentType(building: Building, context: AIContext): string {
    const name = building.name.toLowerCase()
    
    if (name.includes('dashboard') || name.includes('대시보드')) {
      return 'dashboard'
    }
    if (name.includes('form') || name.includes('폼') || name.includes('입력')) {
      return 'form'
    }
    if (name.includes('list') || name.includes('목록') || name.includes('table')) {
      return 'list'
    }
    if (name.includes('profile') || name.includes('프로필')) {
      return 'profile'
    }
    if (name.includes('login') || name.includes('로그인') || name.includes('auth')) {
      return 'auth'
    }
    
    return 'page' // 기본값
  }

  private getComponentPurpose(building: Building, componentType: string): string {
    const purposes: Record<string, string> = {
      dashboard: 'Display key metrics and data visualizations',
      form: 'Collect and validate user input',
      list: 'Display and manage collections of data',
      profile: 'Show and edit user information',
      auth: 'Handle user authentication',
      page: 'General purpose page component',
    }
    
    return purposes[componentType] || purposes.page
  }

  private generateUIRequirements(building: Building, context: AIContext, componentType: string): string {
    const requirements: string[] = []
    
    // 기본 요구사항
    requirements.push('- Responsive design using Tailwind CSS')
    requirements.push('- Loading and error states')
    requirements.push('- TypeScript type safety')
    requirements.push('- Accessibility (ARIA labels, keyboard navigation)')
    
    // 컴포넌트 타입별 요구사항
    switch (componentType) {
      case 'dashboard':
        requirements.push('- Data visualization components')
        requirements.push('- Real-time updates (if applicable)')
        requirements.push('- Export functionality')
        break
      case 'form':
        requirements.push('- Form validation')
        requirements.push('- Error messages')
        requirements.push('- Submit handling')
        requirements.push('- Success feedback')
        break
      case 'list':
        requirements.push('- Pagination or infinite scroll')
        requirements.push('- Sorting and filtering')
        requirements.push('- Bulk actions')
        requirements.push('- Search functionality')
        break
      case 'auth':
        requirements.push('- Secure password input')
        requirements.push('- Remember me option')
        requirements.push('- Social login buttons (if applicable)')
        requirements.push('- Password reset link')
        break
    }
    
    // API 연결이 있는 경우
    if (context.connectedBuildings.some(b => b.type === 'api')) {
      requirements.push('- API integration with proper error handling')
      requirements.push('- Optimistic UI updates')
      requirements.push('- Request cancellation')
    }
    
    return requirements.join('\n')
  }

  private getComponentName(building: Building): string {
    // 건물 이름을 PascalCase로 변환
    return building.name
      .split(/[\s-_]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
  }

  private getComponentPath(building: Building): string {
    // 건물 이름을 kebab-case로 변환
    return building.name
      .toLowerCase()
      .replace(/[\s_]+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
  }

  private generateTypeDefinitions(building: Building, connectedApis: Building[]): CodeFile {
    const componentName = this.getComponentName(building)
    const path = this.getComponentPath(building)
    
    return {
      path: `src/components/${path}/types.ts`,
      content: `// Type definitions for ${componentName}

export interface ${componentName}Props {
  className?: string
  onSuccess?: (data: any) => void
  onError?: (error: Error) => void
}

export interface ${componentName}State {
  isLoading: boolean
  error: string | null
  data: any | null
}

${connectedApis.length > 0 ? `
// API Response Types
export interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
  }
  metadata?: {
    page?: number
    limit?: number
    total?: number
  }
}

// Entity types based on connected APIs
${connectedApis.map(api => `
export interface ${this.getComponentName(api)}Data {
  id: string
  // Add specific fields based on your API
  [key: string]: any
}`).join('\n')}
` : ''}`,
      language: 'typescript',
    }
  }

  private generateApiHooks(building: Building, connectedApis: Building[]): CodeFile {
    const componentName = this.getComponentName(building)
    const path = this.getComponentPath(building)
    
    return {
      path: `src/components/${path}/hooks.ts`,
      content: `// API hooks for ${componentName}

import { useState, useEffect } from 'react'
import { ApiResponse } from './types'

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || '/api'

${connectedApis.map(api => {
  const apiName = this.getComponentName(api)
  const endpoint = api.name.toLowerCase().replace(/\s+/g, '-')
  
  return `
// Hook for ${api.name}
export function use${apiName}() {
  const [data, setData] = useState<any>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const fetchData = async () => {
    setIsLoading(true)
    setError(null)
    
    try {
      const response = await fetch(\`\${API_BASE_URL}/${endpoint}\`)
      
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`)
      }
      
      const result: ApiResponse<any> = await response.json()
      
      if (result.success) {
        setData(result.data)
      } else {
        throw new Error(result.error?.message || 'Unknown error')
      }
    } catch (err) {
      setError(err as Error)
    } finally {
      setIsLoading(false)
    }
  }

  const createItem = async (item: any) => {
    setIsLoading(true)
    setError(null)
    
    try {
      const response = await fetch(\`\${API_BASE_URL}/${endpoint}\`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(item),
      })
      
      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`)
      }
      
      const result: ApiResponse<any> = await response.json()
      
      if (result.success) {
        return result.data
      } else {
        throw new Error(result.error?.message || 'Unknown error')
      }
    } catch (err) {
      setError(err as Error)
      throw err
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    fetchData()
  }, [])

  return {
    data,
    isLoading,
    error,
    refetch: fetchData,
    create: createItem,
  }
}`
}).join('\n')}`,
      language: 'typescript',
    }
  }

  private generateStyles(building: Building): CodeFile {
    const path = this.getComponentPath(building)
    
    return {
      path: `src/components/${path}/styles.module.css`,
      content: `/* Custom styles for ${building.name} */

.container {
  @apply p-6 bg-white rounded-lg shadow-sm;
}

.header {
  @apply text-2xl font-bold mb-4 text-gray-900;
}

.content {
  @apply space-y-4;
}

.card {
  @apply p-4 border border-gray-200 rounded-lg hover:shadow-md transition-shadow;
}

.loading {
  @apply flex items-center justify-center py-12;
}

.error {
  @apply bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded;
}

/* Responsive grid */
.grid {
  @apply grid grid-cols-1 gap-4;
  
  @screen md {
    @apply grid-cols-2;
  }
  
  @screen lg {
    @apply grid-cols-3;
  }
}`,
      language: 'css',
    }
  }

  private generateWarnings(context: AIContext): string[] {
    const warnings: string[] = []
    
    // API 연결 없음 경고
    if (!context.connectedBuildings.some(b => b.type === 'api')) {
      warnings.push('No API connections detected. Component uses mock data.')
    }
    
    // 인증 필요 경고
    if (context.townState.buildings.some(b => b.name.toLowerCase().includes('auth'))) {
      warnings.push('Authentication may be required. Add auth checks if needed.')
    }
    
    // 상태 관리 경고
    if (context.townState.buildings.length > 10) {
      warnings.push('Complex app detected. Consider using global state management.')
    }
    
    return warnings
  }
}
```

## 📋 Task 2: 코드 후처리 시스템

### 2.1 코드 검증기 (src/services/ai/validation/validator.ts)
```typescript
// irke://stack/ai/validation/code
import { CodeFile } from '../types'

export interface ValidationResult {
  isValid: boolean
  errors: ValidationError[]
  warnings: ValidationWarning[]
}

export interface ValidationError {
  file: string
  line?: number
  column?: number
  message: string
  severity: 'error'
  rule: string
}

export interface ValidationWarning {
  file: string
  line?: number
  column?: number
  message: string
  severity: 'warning'
  rule: string
}

export class CodeValidator {
  validateFiles(files: CodeFile[]): ValidationResult {
    const errors: ValidationError[] = []
    const warnings: ValidationWarning[] = []
    
    files.forEach(file => {
      const fileResults = this.validateFile(file)
      errors.push(...fileResults.errors)
      warnings.push(...fileResults.warnings)
    })
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    }
  }

  private validateFile(file: CodeFile): { errors: ValidationError[]; warnings: ValidationWarning[] } {
    const errors: ValidationError[] = []
    const warnings: ValidationWarning[] = []
    
    // 기본 검증
    if (!file.content || file.content.trim().length === 0) {
      errors.push({
        file: file.path,
        message: 'File is empty',
        severity: 'error',
        rule: 'no-empty-files',
      })
    }
    
    // 언어별 검증
    switch (file.language) {
      case 'typescript':
      case 'tsx':
        this.validateTypeScript(file, errors, warnings)
        break
      case 'javascript':
      case 'jsx':
        this.validateJavaScript(file, errors, warnings)
        break
      case 'sql':
        this.validateSQL(file, errors, warnings)
        break
    }
    
    return { errors, warnings }
  }

  private validateTypeScript(file: CodeFile, errors: ValidationError[], warnings: ValidationWarning[]) {
    const content = file.content
    
    // any 타입 사용 경고
    if (content.includes(': any')) {
      warnings.push({
        file: file.path,
        message: 'Usage of "any" type detected. Consider using specific types.',
        severity: 'warning',
        rule: 'no-any',
      })
    }
    
    // console.log 경고
    if (content.includes('console.log')) {
      warnings.push({
        file: file.path,
        message: 'console.log statements should be removed in production',
        severity: 'warning',
        rule: 'no-console',
      })
    }
    
    // TODO 주석 경고
    if (content.includes('TODO')) {
      warnings.push({
        file: file.path,
        message: 'TODO comments found',
        severity: 'warning',
        rule: 'no-todo',
      })
    }
    
    // 필수 import 확인
    if (file.language === 'tsx' && !content.includes('import React') && !content.includes("'use client'")) {
      errors.push({
        file: file.path,
        message: 'React import missing in TSX file',
        severity: 'error',
        rule: 'react-import',
      })
    }
  }

  private validateJavaScript(file: CodeFile, errors: ValidationError[], warnings: ValidationWarning[]) {
    // TypeScript 검증과 유사하지만 타입 관련 검증 제외
    this.validateTypeScript(file, errors, warnings)
  }

  private validateSQL(file: CodeFile, errors: ValidationError[], warnings: ValidationWarning[]) {
    const content = file.content.toUpperCase()
    
    // 위험한 SQL 명령어 검사
    if (content.includes('DROP DATABASE') || content.includes('TRUNCATE')) {
      warnings.push({
        file: file.path,
        message: 'Dangerous SQL commands detected',
        severity: 'warning',
        rule: 'no-dangerous-sql',
      })
    }
    
    // 인덱스 누락 경고
    if (content.includes('CREATE TABLE') && !content.includes('CREATE INDEX')) {
      warnings.push({
        file: file.path,
        message: 'No indexes defined. Consider adding indexes for better performance.',
        severity: 'warning',
        rule: 'missing-indexes',
      })
    }
  }
}
```

### 2.2 코드 포맷터 (src/services/ai/formatting/formatter.ts)
```typescript
// irke://stack/ai/formatting/code
import { CodeFile } from '../types'
import prettier from 'prettier'

export class CodeFormatter {
  async formatFiles(files: CodeFile[]): Promise<CodeFile[]> {
    const formattedFiles = await Promise.all(
      files.map(file => this.formatFile(file))
    )
    
    return formattedFiles
  }

  private async formatFile(file: CodeFile): Promise<CodeFile> {
    try {
      const formatted = await this.format(file.content, file.language)
      
      return {
        ...file,
        content: formatted,
      }
    } catch (error) {
      console.error(`Failed to format ${file.path}:`, error)
      // 포맷팅 실패 시 원본 반환
      return file
    }
  }

  private async format(code: string, language: string): Promise<string> {
    const parserMap: Record<string, string> = {
      typescript: 'typescript',
      javascript: 'babel',
      tsx: 'typescript',
      jsx: 'babel',
      css: 'css',
      scss: 'scss',
      json: 'json',
      html: 'html',
      markdown: 'markdown',
      yaml: 'yaml',
    }

    const parser = parserMap[language]
    
    if (!parser) {
      // Prettier가 지원하지 않는 언어는 원본 반환
      return code
    }

    try {
      const formatted = await prettier.format(code, {
        parser,
        semi: false,
        singleQuote: true,
        tabWidth: 2,
        trailingComma: 'es5',
        printWidth: 100,
        bracketSpacing: true,
        arrowParens: 'always',
        ...(language === 'tsx' || language === 'jsx' ? {
          jsxSingleQuote: false,
          jsxBracketSameLine: false,
        } : {}),
      })

      return formatted
    } catch (error) {
      console.error('Prettier formatting error:', error)
      return code
    }
  }

  // SQL 특별 포맷팅
  formatSQL(sql: string): string {
    // 간단한 SQL 포맷팅
    return sql
      .replace(/\s+/g, ' ')
      .replace(/\s*,\s*/g, ',\n  ')
      .replace(/\s*\(\s*/g, ' (\n  ')
      .replace(/\s*\)\s*/g, '\n)')
      .replace(/\bSELECT\b/gi, 'SELECT')
      .replace(/\bFROM\b/gi, '\nFROM')
      .replace(/\bWHERE\b/gi, '\nWHERE')
      .replace(/\bAND\b/gi, '\n  AND')
      .replace(/\bOR\b/gi, '\n  OR')
      .replace(/\bORDER BY\b/gi, '\nORDER BY')
      .replace(/\bGROUP BY\b/gi, '\nGROUP BY')
      .trim()
  }
}
```

### 2.3 의존성 관리자 (src/services/ai/dependencies/manager.ts)
```typescript
// irke://stack/ai/dependencies/manager
export interface PackageInfo {
  name: string
  version?: string
  isDevDependency?: boolean
}

export class DependencyManager {
  private commonDependencies: Map<string, PackageInfo>

  constructor() {
    this.commonDependencies = new Map([
      // React 생태계
      ['react', { name: 'react', version: '^18.0.0' }],
      ['react-dom', { name: 'react-dom', version: '^18.0.0' }],
      ['next', { name: 'next', version: '^14.0.0' }],
      
      // 타입 정의
      ['@types/react', { name: '@types/react', version: '^18.0.0', isDevDependency: true }],
      ['@types/node', { name: '@types/node', version: '^20.0.0', isDevDependency: true }],
      
      // 유틸리티
      ['clsx', { name: 'clsx', version: '^2.0.0' }],
      ['date-fns', { name: 'date-fns', version: '^3.0.0' }],
      
      // UI 라이브러리
      ['lucide-react', { name: 'lucide-react', version: '^0.300.0' }],
      ['@headlessui/react', { name: '@headlessui/react', version: '^1.7.0' }],
      
      // 폼/검증
      ['react-hook-form', { name: 'react-hook-form', version: '^7.48.0' }],
      ['zod', { name: 'zod', version: '^3.22.0' }],
      
      // 데이터 페칭
      ['swr', { name: 'swr', version: '^2.2.0' }],
      ['@tanstack/react-query', { name: '@tanstack/react-query', version: '^5.0.0' }],
      
      // 데이터베이스
      ['@prisma/client', { name: '@prisma/client', version: '^5.0.0' }],
      ['prisma', { name: 'prisma', version: '^5.0.0', isDevDependency: true }],
    ])
  }

  resolveDependencies(dependencies: string[]): PackageInfo[] {
    const resolved: PackageInfo[] = []
    const added = new Set<string>()
    
    dependencies.forEach(dep => {
      const info = this.commonDependencies.get(dep) || { name: dep }
      
      if (!added.has(info.name)) {
        resolved.push(info)
        added.add(info.name)
        
        // 추가 의존성 확인
        const additional = this.getAdditionalDependencies(dep)
        additional.forEach(add => {
          if (!added.has(add.name)) {
            resolved.push(add)
            added.add(add.name)
          }
        })
      }
    })
    
    return resolved
  }

  private getAdditionalDependencies(dep: string): PackageInfo[] {
    const additional: PackageInfo[] = []
    
    // React Query는 추가 설정 필요
    if (dep === '@tanstack/react-query') {
      additional.push({ name: '@tanstack/react-query-devtools', isDevDependency: true })
    }
    
    // Prisma는 타입 생성기 필요
    if (dep === '@prisma/client') {
      additional.push({ name: 'prisma', isDevDependency: true })
    }
    
    // TypeScript 프로젝트에는 타입 정의 추가
    if (dep.startsWith('@types/')) {
      // 이미 dev dependency
    } else if (!dep.startsWith('@') && this.commonDependencies.has(`@types/${dep}`)) {
      additional.push(this.commonDependencies.get(`@types/${dep}`)!)
    }
    
    return additional
  }

  generatePackageJson(dependencies: PackageInfo[]): string {
    const deps: Record<string, string> = {}
    const devDeps: Record<string, string> = {}
    
    dependencies.forEach(dep => {
      if (dep.isDevDependency) {
        devDeps[dep.name] = dep.version || 'latest'
      } else {
        deps[dep.name] = dep.version || 'latest'
      }
    })
    
    return JSON.stringify({
      dependencies: deps,
      devDependencies: devDeps,
    }, null, 2)
  }
}
```

## 🧪 테스트 체크리스트

### 코드 생성 테스트
- [ ] API Gateway 코드 생성
- [ ] Database 스키마 생성
- [ ] Frontend 컴포넌트 생성
- [ ] 연결된 건물 컨텍스트 반영
- [ ] 의존성 올바른 추출

### 코드 품질 테스트
- [ ] TypeScript 타입 안전성
- [ ] 코드 포맷팅 일관성
- [ ] 에러 핸들링 포함
- [ ] 주석 및 문서화

### 통합 테스트
- [ ] 생성된 코드 실행 가능
- [ ] API-Database 연동
- [ ] Frontend-API 연동
- [ ] 의존성 설치 가능

## 📝 Sprint 2.3 준비사항

### 전달할 인터페이스
```typescript
// AI 대화 시스템을 위한 인터페이스
export interface ChatInterface {
  sendMessage(message: string, context: AIContext): Promise<ChatResponse>
  streamMessage(message: string, context: AIContext): AsyncGenerator<string>
  getHistory(): Message[]
  clearHistory(): void
}

export interface ChatResponse {
  message: string
  codeGenerated?: GeneratedCode
  intent: Intent
  suggestions?: string[]
}
```

## 🎯 완료 기준
- 3종 건물별 코드 생성기 구현
- 컨텍스트 인식 코드 생성
- 코드 검증 및 포맷팅
- 의존성 자동 추출
- 프리뷰 가능한 코드 생성

---

*Sprint 2.2가 완료되면 건물별로 실제 작동하는 코드를 생성할 수 있습니다. 생성된 코드는 즉시 사용 가능한 품질입니다.*